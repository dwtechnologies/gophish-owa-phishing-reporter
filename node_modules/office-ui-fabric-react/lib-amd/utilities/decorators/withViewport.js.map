{"version":3,"file":"withViewport.js","sourceRoot":"../src/","sources":["utilities/decorators/withViewport.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow } from '../../Utilities';\n\n/**\n * Viewport rectangle dimensions.\n *\n * {@docCategory DetailsList}\n */\nexport interface IViewport {\n  /**\n   * Width in pixels.\n   */\n  width: number;\n  /**\n   * Height in pixels.\n   */\n  height: number;\n}\n\nexport interface IWithViewportState {\n  viewport?: IViewport;\n}\n\n/**\n * Props interface for the withViewport component.\n *\n * {@docCategory DetailsList}\n */\nexport interface IWithViewportProps {\n  /**\n   * Whether or not to use ResizeObserver (if available) to detect\n   * and measure viewport on 'resize' events.\n   *\n   * Falls back to window 'resize' event.\n   *\n   * @defaultValue false\n   */\n  skipViewportMeasures?: boolean;\n}\n\nconst RESIZE_DELAY = 500;\nconst MAX_RESIZE_ATTEMPTS = 3;\n\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent decorated React component reference.\n */\nexport function withViewport<TProps extends { viewport?: IViewport }, TState>(\n  ComposedComponent: new (props: TProps, ...args: any[]) => React.Component<TProps, TState>\n): any {\n  return class WithViewportComponent extends BaseDecorator<TProps, IWithViewportState> {\n    private _root = React.createRef<HTMLDivElement>();\n    private _resizeAttempts: number;\n    private _viewportResizeObserver: any;\n\n    constructor(props: TProps) {\n      super(props);\n      this._resizeAttempts = 0;\n\n      this.state = {\n        viewport: {\n          width: 0,\n          height: 0\n        }\n      };\n    }\n\n    public componentDidMount(): void {\n      const { skipViewportMeasures } = this.props as IWithViewportProps;\n      const win = getWindow();\n\n      this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n        leading: false\n      });\n\n      // ResizeObserver seems always fire even window is not resized. This is\n      // particularly bad when skipViewportMeasures is set when optimizing fixed layout lists.\n      // It will measure and update and re-render the entire list after list is fully rendered.\n      // So fallback to listen to resize event when skipViewportMeasures is set.\n      if (!skipViewportMeasures && this._isResizeObserverAvailable()) {\n        this._registerResizeObserver();\n      } else {\n        this._events.on(win, 'resize', this._onAsyncResize);\n      }\n\n      if (!skipViewportMeasures) {\n        this._updateViewport();\n      }\n    }\n\n    public componentDidUpdate(newProps: TProps) {\n      const { skipViewportMeasures: oldSkipViewportMeasures } = this.props as IWithViewportProps;\n      const { skipViewportMeasures: newSkipViewportMeasures } = newProps as IWithViewportProps;\n      const win = getWindow();\n\n      if (oldSkipViewportMeasures !== newSkipViewportMeasures) {\n        if (newSkipViewportMeasures) {\n          this._unregisterResizeObserver();\n          this._events.on(win, 'resize', this._onAsyncResize);\n        } else if (!newSkipViewportMeasures && this._isResizeObserverAvailable()) {\n          this._events.off(win, 'resize', this._onAsyncResize);\n          this._registerResizeObserver();\n        }\n      }\n\n      if (!!newSkipViewportMeasures) {\n        this._updateViewport();\n      }\n    }\n\n    public componentWillUnmount(): void {\n      this._events.dispose();\n\n      if (this._viewportResizeObserver) {\n        this._viewportResizeObserver.disconnect();\n      }\n    }\n\n    public render(): JSX.Element {\n      const { viewport } = this.state;\n      const newViewport = viewport!.width > 0 && viewport!.height > 0 ? viewport : undefined;\n\n      return (\n        <div className=\"ms-Viewport\" ref={this._root} style={{ minWidth: 1, minHeight: 1 }}>\n          <ComposedComponent ref={this._updateComposedComponentRef} viewport={newViewport} {...this.props as any} />\n        </div>\n      );\n    }\n\n    public forceUpdate(): void {\n      this._updateViewport(true);\n    }\n\n    private _onAsyncResize(): void {\n      this._updateViewport();\n    }\n\n    private _isResizeObserverAvailable(): boolean {\n      const win = getWindow();\n\n      return win && (win as any).ResizeObserver;\n    }\n\n    private _registerResizeObserver = () => {\n      const win = getWindow();\n\n      this._viewportResizeObserver = new (win as any).ResizeObserver(this._onAsyncResize);\n      this._viewportResizeObserver.observe(this._root.current);\n    };\n\n    private _unregisterResizeObserver = () => {\n      if (this._viewportResizeObserver) {\n        this._viewportResizeObserver.disconnect();\n        this._viewportResizeObserver = null;\n      }\n    };\n\n    /* Note: using lambda here because decorators don't seem to work in decorators. */\n    private _updateViewport = (withForceUpdate?: boolean) => {\n      const { viewport } = this.state;\n      const viewportElement = this._root.current;\n      const scrollElement = findScrollableParent(viewportElement);\n      const scrollRect = getRect(scrollElement);\n      const clientRect = getRect(viewportElement);\n      const updateComponent = () => {\n        if (withForceUpdate && this._composedComponentInstance) {\n          this._composedComponentInstance.forceUpdate();\n        }\n      };\n\n      const isSizeChanged = (clientRect && clientRect.width) !== viewport!.width || (scrollRect && scrollRect.height) !== viewport!.height;\n\n      if (isSizeChanged && this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n        this._resizeAttempts++;\n        this.setState(\n          {\n            viewport: {\n              width: clientRect.width,\n              height: scrollRect.height\n            }\n          },\n          () => {\n            this._updateViewport(withForceUpdate);\n          }\n        );\n      } else {\n        this._resizeAttempts = 0;\n        updateComponent();\n      }\n    };\n  };\n}\n"]}