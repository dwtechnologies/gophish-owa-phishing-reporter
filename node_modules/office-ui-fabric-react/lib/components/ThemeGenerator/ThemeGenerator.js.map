{"version":3,"file":"ThemeGenerator.js","sourceRoot":"../src/","sources":["components/ThemeGenerator/ThemeGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["import { IColor } from '../../utilities/color/interfaces';\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { isValidShade, getShade, getBackgroundShade } from '../../utilities/color/shades';\nimport { format } from '../../Utilities';\n\nimport { IThemeSlotRule } from './IThemeSlotRule';\nimport { IThemeRules } from './IThemeRules';\n\nexport class ThemeGenerator {\n  /* Sets an IThemeSlotRule to the given color and cascades it to the rest of the theme, updating other IThemeSlotRules in the theme that\n   *   inherit from that color.\n   * isInverted: whether it's a dark theme or not, which affects the algorithm used to generate shades\n   * isCustomization should be true only if it's a user action, and indicates overwriting the slot's inheritance (if any)\n   * overwriteCustomColor: a slot could have a generated color based on its inheritance rules (isCustomized is false), or a custom color\n                            based on user input (isCustomized is true), this bool tells us whether to override existing customized colors */\n  public static setSlot(\n    rule: IThemeSlotRule,\n    color: string | IColor,\n    isInverted = false,\n    isCustomization = false,\n    overwriteCustomColor = true\n  ) {\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor) {\n      let colorAsIColor: IColor;\n      if (typeof color === 'string') {\n        colorAsIColor = getColorFromString(color)!; // the ! is a lie here but we'll verify it in the next line\n        if (!colorAsIColor) {\n          throw 'color is invalid in setSlot(): ' + color;\n        }\n      } else {\n        colorAsIColor = color;\n      }\n      ThemeGenerator._setSlot(rule, colorAsIColor, isInverted, isCustomization, overwriteCustomColor);\n    } else if (rule.color) {\n      ThemeGenerator._setSlot(rule, rule.color, isInverted, isCustomization, overwriteCustomColor);\n    }\n  }\n\n  /* Sets the color of each slot based on its rule. Slots that don't inherit must have a color already.\n   * If this completes without error, then the theme is ready to use. (All slots will have a color.)\n   * setSlot() can be called before this, but this must be called before getThemeAs*().\n   * Does not override colors of rules where isCustomized is true (i.e. doesn't override existing customizations).\n   */\n  public static insureSlots(slotRules: IThemeRules, isInverted: boolean) {\n    // Get all the \"root\" rules, the ones which don't inherit. Then \"set\" them to trigger updating dependent slots.\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        if (!rule.inherits && !rule.value) {\n          if (!rule.color) {\n            throw 'A color slot rule that does not inherit must provide its own color.';\n          }\n          ThemeGenerator._setSlot(rule, rule.color, isInverted, false, false);\n        }\n      }\n    }\n  }\n\n  /* Gets the JSON-formatted blob that describes the theme, usable with the REST request endpoints\n   * { [theme slot name as string] : [color as string],\n   *  \"tokenName\": \"#f00f00\",\n   *  \"tokenName2\": \"#ba2ba2\",\n   *   ... }\n   */\n  public static getThemeAsJson(slotRules: IThemeRules): any {\n    const theme: any = {};\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        theme[rule.name] = rule.color ? rule.color.str : rule.value || '';\n      }\n    }\n    return theme;\n  }\n\n  /*\n   * Gets code-formatted load theme blob that can be copy and pasted.\n   */\n  public static getThemeAsCode(slotRules: IThemeRules): any {\n    const attributeTemplate = \"    {0}: '{1}',\\n\";\n    let output = '';\n\n    output += 'loadTheme({\\n  palette: {\\n';\n\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        const outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';\n        output += format(attributeTemplate, camelCasedName, outputColor);\n      }\n    }\n    output += '  }\\n});';\n    return output;\n  }\n\n  /* Gets the theme as a list of SASS variables that can be used in code\n   * $tokenName: \"[theme:tokenName, default:#f00f00]\";\n   * $tokenName2: \"[theme:tokenName2, default:#ba2ba2]\";\n   * ...\n   */\n  public static getThemeAsSass(slotRules: IThemeRules): any {\n    const sassVarTemplate = '${0}Color: \"[theme: {1}, default: {2}]\";\\n';\n    let output = '';\n\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        output += format(sassVarTemplate, camelCasedName, camelCasedName, rule.color ? rule.color.str : rule.value || '');\n      }\n    }\n    return output;\n  }\n\n  /* Gets the theme formatted for PowerShell scripts\n   * @{\n   * \"tokenName\" = \"#f00f00\";\n   * \"tokenName2\" = \"#ba2ba2\";\n   * ...\n   * }\n   */\n  public static getThemeForPowerShell(slotRules: IThemeRules): any {\n    const psVarTemplate = '\"{0}\" = \"{1}\";\\n';\n    let output = '';\n\n    for (const ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        const rule: IThemeSlotRule = slotRules[ruleName];\n        if (rule.value) {\n          // skip this one, it's not a color\n          continue;\n        }\n        const camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        let outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';\n        // powershell endpoint uses the RGBA format\n        if (rule.color && rule.color.a && rule.color.a !== 100) {\n          outputColor += String(rule.color.a.toString(16));\n        }\n        output += format(psVarTemplate, camelCasedName, outputColor);\n      }\n    }\n    return '@{\\n' + output + '}';\n  }\n\n  /* Sets the given slot's color to the appropriate color, shading it if necessary.\n     Then, iterates through all other rules (that are this rule's dependents) to update them accordingly.\n     isCustomization=true means it's a user provided color, set it to that raw color\n     isCustomization=false means the rule it's inheriting from changed, so updated using asShade */\n  private static _setSlot(rule: IThemeSlotRule, color: IColor, isInverted: boolean, isCustomization: boolean, overwriteCustomColor = true) {\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor || !rule.color || !rule.isCustomized || !rule.inherits) {\n      // set the rule's color under these conditions\n      if ((overwriteCustomColor || !rule.isCustomized) && !isCustomization && rule.inherits && isValidShade(rule.asShade)) {\n        // it's inheriting by shade\n        if (rule.isBackgroundShade) {\n          rule.color = getBackgroundShade(color, rule.asShade!, isInverted)!;\n        } else {\n          rule.color = getShade(color, rule.asShade!, isInverted)!;\n        }\n        rule.isCustomized = false;\n      } else {\n        rule.color = color;\n        rule.isCustomized = true;\n      }\n\n      // then update dependent colors\n      for (const ruleToUpdate of rule.dependentRules) {\n        ThemeGenerator._setSlot(ruleToUpdate, rule.color, isInverted, false, overwriteCustomColor);\n      }\n    }\n  }\n}\n"]}