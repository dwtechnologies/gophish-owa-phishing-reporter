define(["require", "exports", "@uifabric/merge-styles"], function (require, exports, merge_styles_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MAX_CACHE_COUNT = 50;
    var _memoizedClassNames = 0;
    var stylesheet = merge_styles_1.Stylesheet.getInstance();
    if (stylesheet && stylesheet.onReset) {
        stylesheet.onReset(function () { return _memoizedClassNames++; });
    }
    // Note that because of the caching nature within the classNames memoization,
    // I've disabled this rule to simply be able to work with any types.
    // tslint:disable:no-any
    // This represents a prop we attach to each Map to indicate the cached return value
    // associated with the graph node.
    var RetVal = '__retval__';
    /**
     * Creates a getClassNames function which calls getStyles given the props, and injects them
     * into mergeStyleSets.
     *
     * Note that the props you pass in on every render should be in the same order and
     * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating
     * these will cause extra recalcs to occur.
     */
    function classNamesFunction(options) {
        // We build a trie where each node is a Map. The map entry key represents an argument
        // value, and the entry value is another node (Map). Each node has a `__retval__`
        // property which is used to hold the cached response.
        if (options === void 0) { options = {}; }
        // To derive the response, we can simply ensure the arguments are added or already
        // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise
        // we call the `getStyles` api to evaluate, cache on the property, and return that.
        var map = new Map();
        var resultCount = 0;
        var currentMemoizedClassNames = _memoizedClassNames;
        var getClassNames = function (styleFunctionOrObject, styleProps) {
            if (styleProps === void 0) { styleProps = {}; }
            var current = map;
            var disableCaching = options.disableCaching;
            // On reset of our stylesheet, reset memoized cache.
            if (currentMemoizedClassNames !== _memoizedClassNames) {
                currentMemoizedClassNames = _memoizedClassNames;
                map = new Map();
                resultCount = 0;
            }
            if (!options.disableCaching) {
                current = _traverseMap(map, styleFunctionOrObject);
                current = _traverseMap(current, styleProps);
            }
            if (disableCaching || !current[RetVal]) {
                if (styleFunctionOrObject === undefined) {
                    current[RetVal] = {};
                }
                else {
                    current[RetVal] = merge_styles_1.mergeStyleSets((typeof styleFunctionOrObject === 'function'
                        ? styleFunctionOrObject(styleProps)
                        : styleFunctionOrObject));
                }
                if (!disableCaching) {
                    resultCount++;
                }
            }
            if (resultCount > MAX_CACHE_COUNT) {
                map.clear();
                resultCount = 0;
                // Mutate the options passed in, that's all we can do.
                options.disableCaching = true;
                // Note: this code is great for debugging problems with styles being recaculated, but commenting it out
                // to avoid confusing consumers.
                // if (process.env.NODE_ENV !== 'production') {
                //  console.log('Styles are being recalculated far too frequently. Something is mutating the class over and over.');
                //  // tslint:disable-next-line:no-console
                //  console.trace();
                // }
            }
            // Note: the RetVal is an attached property on the Map; not a key in the Map. We use this attached property to
            // cache the return value for this branch of the graph.
            return current[RetVal];
        };
        return getClassNames;
    }
    exports.classNamesFunction = classNamesFunction;
    function _traverseEdge(current, value) {
        value = _normalizeValue(value);
        if (!current.has(value)) {
            current.set(value, new Map());
        }
        return current.get(value);
    }
    function _traverseMap(current, inputs) {
        // The styled helper will generate the styles function and will attach the cached
        // inputs (consisting of the default styles, customzied styles, and user provided styles.)
        // These should be used as cache keys for deriving the memoized value.
        if (typeof inputs === 'function' && inputs.__cachedInputs__) {
            for (var _i = 0, _a = inputs.__cachedInputs__; _i < _a.length; _i++) {
                var input = _a[_i];
                current = _traverseEdge(current, input);
            }
        }
        else if (typeof inputs === 'object') {
            for (var propName in inputs) {
                if (inputs.hasOwnProperty(propName)) {
                    current = _traverseEdge(current, inputs[propName]);
                }
            }
        }
        return current;
    }
    function _normalizeValue(value) {
        switch (value) {
            case undefined:
                return '__undefined__';
            case null:
                return '__null__';
            default:
                return value;
        }
    }
});
//# sourceMappingURL=classNamesFunction.js.map