{"version":3,"file":"classNamesFunction.js","sourceRoot":"../src/","sources":["classNamesFunction.ts"],"names":[],"mappings":"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","sourcesContent":["import { mergeStyleSets, IStyleSet, IProcessedStyleSet, Stylesheet } from '@uifabric/merge-styles';\nimport { IStyleFunctionOrObject } from '@uifabric/merge-styles';\n\nconst MAX_CACHE_COUNT = 50;\nlet _memoizedClassNames = 0;\n\nconst stylesheet = Stylesheet.getInstance();\n\nif (stylesheet && stylesheet.onReset) {\n  stylesheet.onReset(() => _memoizedClassNames++);\n}\n\n// Note that because of the caching nature within the classNames memoization,\n// I've disabled this rule to simply be able to work with any types.\n// tslint:disable:no-any\n\n// This represents a prop we attach to each Map to indicate the cached return value\n// associated with the graph node.\nconst RetVal = '__retval__';\n\ninterface IRecursiveMemoNode extends Map<any, IRecursiveMemoNode> {\n  [RetVal]?: string;\n}\n\nexport interface IClassNamesFunctionOptions {\n  /**\n   * Disables class caching for scenarios where styleProp parts mutate frequently.\n   */\n  disableCaching?: boolean;\n}\n\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n *\n * Note that the props you pass in on every render should be in the same order and\n * immutable (numbers, strings, and booleans). This will allow the results to be memoized. Violating\n * these will cause extra recalcs to occur.\n */\nexport function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSet<TStyleSet>>(\n  options: IClassNamesFunctionOptions = {}\n): (getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined, styleProps?: TStyleProps) => IProcessedStyleSet<TStyleSet> {\n  // We build a trie where each node is a Map. The map entry key represents an argument\n  // value, and the entry value is another node (Map). Each node has a `__retval__`\n  // property which is used to hold the cached response.\n\n  // To derive the response, we can simply ensure the arguments are added or already\n  // exist in the trie. At the last node, if there is a `__retval__` we return that. Otherwise\n  // we call the `getStyles` api to evaluate, cache on the property, and return that.\n  let map: IRecursiveMemoNode = new Map();\n  let resultCount = 0;\n  let currentMemoizedClassNames = _memoizedClassNames;\n\n  const getClassNames = (\n    styleFunctionOrObject: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n    styleProps: TStyleProps = {} as TStyleProps\n  ): IProcessedStyleSet<TStyleSet> => {\n    let current: Map<any, any> = map;\n    const disableCaching = options.disableCaching;\n\n    // On reset of our stylesheet, reset memoized cache.\n    if (currentMemoizedClassNames !== _memoizedClassNames) {\n      currentMemoizedClassNames = _memoizedClassNames;\n      map = new Map();\n      resultCount = 0;\n    }\n\n    if (!options.disableCaching) {\n      current = _traverseMap(map, styleFunctionOrObject as any);\n      current = _traverseMap(current, styleProps);\n    }\n\n    if (disableCaching || !(current as any)[RetVal]) {\n      if (styleFunctionOrObject === undefined) {\n        (current as any)[RetVal] = {} as IProcessedStyleSet<TStyleSet>;\n      } else {\n        (current as any)[RetVal] = mergeStyleSets((typeof styleFunctionOrObject === 'function'\n          ? styleFunctionOrObject(styleProps)\n          : styleFunctionOrObject) as IStyleSet<TStyleSet>);\n      }\n\n      if (!disableCaching) {\n        resultCount++;\n      }\n    }\n\n    if (resultCount > MAX_CACHE_COUNT) {\n      map.clear();\n      resultCount = 0;\n\n      // Mutate the options passed in, that's all we can do.\n      options.disableCaching = true;\n\n      // Note: this code is great for debugging problems with styles being recaculated, but commenting it out\n      // to avoid confusing consumers.\n\n      // if (process.env.NODE_ENV !== 'production') {\n      //  console.log('Styles are being recalculated far too frequently. Something is mutating the class over and over.');\n      //  // tslint:disable-next-line:no-console\n      //  console.trace();\n      // }\n    }\n\n    // Note: the RetVal is an attached property on the Map; not a key in the Map. We use this attached property to\n    // cache the return value for this branch of the graph.\n    return (current as any)[RetVal];\n  };\n\n  return getClassNames;\n}\n\nfunction _traverseEdge(current: Map<any, any>, value: any): Map<any, any> {\n  value = _normalizeValue(value);\n\n  if (!current.has(value)) {\n    current.set(value, new Map<any, any>());\n  }\n\n  return current.get(value);\n}\n\nfunction _traverseMap(current: Map<any, any>, inputs: any[] | Object): Map<any, any> {\n  // The styled helper will generate the styles function and will attach the cached\n  // inputs (consisting of the default styles, customzied styles, and user provided styles.)\n  // These should be used as cache keys for deriving the memoized value.\n  if (typeof inputs === 'function' && (inputs as any).__cachedInputs__) {\n    for (const input of (inputs as any).__cachedInputs__) {\n      current = _traverseEdge(current, input);\n    }\n  } else if (typeof inputs === 'object') {\n    for (const propName in inputs) {\n      if (inputs.hasOwnProperty(propName)) {\n        current = _traverseEdge(current, (inputs as any)[propName]);\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction _normalizeValue(value: any): string {\n  switch (value) {\n    case undefined:\n      return '__undefined__';\n    case null:\n      return '__null__';\n    default:\n      return value;\n  }\n}\n"]}