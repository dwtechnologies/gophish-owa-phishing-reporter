{"version":3,"file":"getWindow.js","sourceRoot":"../src/","sources":["dom/getWindow.ts"],"names":[],"mappings":";;;IAEA,IAAI,OAAO,GAAuB,SAAS,CAAC;IAE5C,sFAAsF;IACtF,iFAAiF;IACjF,0EAA0E;IAC1E,IAAI;QACF,OAAO,GAAG,MAAM,CAAC;KAClB;IAAC,OAAO,CAAC,EAAE;QACV,WAAW;KACZ;IAED;;;;;;;OAOG;IACH,SAAgB,SAAS,CAAC,WAA4B;QACpD,IAAI,eAAM,IAAI,OAAO,OAAO,KAAK,WAAW,EAAE;YAC5C,OAAO,SAAS,CAAC;SAClB;aAAM;YACL,OAAO,WAAW,IAAI,WAAW,CAAC,aAAa,IAAI,WAAW,CAAC,aAAa,CAAC,WAAW;gBACtF,CAAC,CAAC,WAAW,CAAC,aAAa,CAAC,WAAW;gBACvC,CAAC,CAAC,OAAO,CAAC;SACb;IACH,CAAC;IARD,8BAQC","sourcesContent":["import { _isSSR } from './setSSR';\n\nlet _window: Window | undefined = undefined;\n\n// Note: Accessing \"window\" in IE11 is somewhat expensive, and calling \"typeof window\"\n// hits a memory leak, whereas aliasing it and calling \"typeof _window\" does not.\n// Caching the window value at the file scope lets us minimize the impact.\ntry {\n  _window = window;\n} catch (e) {\n  /* no-op */\n}\n\n/**\n * Helper to get the window object. The helper will make sure to use a cached variable\n * of \"window\", to avoid overhead and memory leaks in IE11. Note that in popup scenarios the\n * window object won't match the \"global\" window object, and for these scenarios, you should\n * pass in an element hosted within the popup.\n *\n * @public\n */\nexport function getWindow(rootElement?: Element | null): Window | undefined {\n  if (_isSSR || typeof _window === 'undefined') {\n    return undefined;\n  } else {\n    return rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView\n      ? rootElement.ownerDocument.defaultView\n      : _window;\n  }\n}\n"]}