{"version":3,"file":"styled.js","sourceRoot":"../src/","sources":["styled.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { concatStyleSets, IStyleSet, IStyleFunctionOrObject } from '@uifabric/merge-styles';\nimport { Customizations } from './customizations/Customizations';\nimport { CustomizerContext, ICustomizerContext } from './customizations/CustomizerContext';\n\nexport interface IPropsWithStyles<TStyleProps, TStyleSet extends IStyleSet<TStyleSet>> {\n  styles?: IStyleFunctionOrObject<TStyleProps, TStyleSet>;\n}\n\nexport interface ICustomizableProps {\n  /**\n   * Name of scope, which can be targeted using the Customizer.\n   */\n  scope: string;\n\n  /**\n   * List of fields which can be customized.\n   * @defaultvalue [ 'theme', 'styles' ]\n   */\n  fields?: string[];\n}\n\nconst DefaultFields = ['theme', 'styles'];\n\n/**\n * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve\n * getStyles functional props, and mix customized props passed in using concatStyleSets.\n *\n * @example\n * ```tsx\n * export const Toggle = styled(\n *   ToggleBase,\n *   props => ({ root: { background: 'red' }})\n * );\n * ```\n * @param Component - The unstyled base component to render, which receives styles.\n * @param baseStyles - The styles which should be curried with the component.\n * @param getProps - A helper which provides default props.\n * @param customizable - An object which defines which props can be customized using the Customizer.\n * @param pure - A boolean indicating if the component should avoid re-rendering when props haven't changed.\n * Note that pure should not be used on components which allow children, or take in complex objects or\n * arrays as props which could mutate on every render.\n */\nexport function styled<\n  TComponentProps extends IPropsWithStyles<TStyleProps, TStyleSet>,\n  TStyleProps,\n  TStyleSet extends IStyleSet<TStyleSet>\n>(\n  Component: React.ComponentClass<TComponentProps> | React.StatelessComponent<TComponentProps>,\n  baseStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>,\n  getProps?: (props: TComponentProps) => Partial<TComponentProps>,\n  customizable?: ICustomizableProps,\n  pure?: boolean\n): React.StatelessComponent<TComponentProps> {\n  customizable = customizable || { scope: '', fields: undefined };\n\n  const { scope, fields = DefaultFields } = customizable;\n  const ParentComponent = pure ? React.PureComponent : React.Component;\n\n  class Wrapped extends ParentComponent<TComponentProps, {}> {\n    // Function.prototype.name is an ES6 feature, so the cast to any is required until we're\n    // able to drop IE 11 support and compile with ES6 libs\n    // tslint:disable-next-line:no-any\n    public static displayName = `Styled${Component.displayName || (Component as any).name}`;\n\n    private _inCustomizerContext = false;\n    private _styles: IStyleFunctionOrObject<TStyleProps, TStyleSet>;\n\n    public render(): JSX.Element {\n      return <CustomizerContext.Consumer>{this._renderContent}</CustomizerContext.Consumer>;\n    }\n\n    public componentDidMount(): void {\n      if (!this._inCustomizerContext) {\n        Customizations.observe(this._onSettingsChanged);\n      }\n    }\n\n    public componentWillUnmount(): void {\n      if (!this._inCustomizerContext) {\n        Customizations.unobserve(this._onSettingsChanged);\n      }\n    }\n\n    private _renderContent = (context: ICustomizerContext): JSX.Element => {\n      this._inCustomizerContext = !!context.customizations.inCustomizerContext;\n\n      const settings = Customizations.getSettings(fields, scope, context.customizations);\n      const { styles: customizedStyles, dir, ...rest } = settings;\n      const additionalProps = getProps ? getProps(this.props) : undefined;\n\n      this._updateStyles(customizedStyles);\n\n      return <Component {...rest} {...additionalProps} {...this.props} styles={this._styles} />;\n    };\n\n    private _updateStyles(customizedStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet>): void {\n      // tslint:disable-next-line:no-any\n      if (!this._styles || customizedStyles !== (this._styles as any).__cachedInputs__[1] || !!this.props.styles) {\n        // Cache the customized styles.\n        // this._customizedStyles = customizedStyles;\n\n        // Using styled components as the Component arg will result in nested styling arrays.\n        this._styles = (styleProps: TStyleProps) => _resolve(styleProps, baseStyles, customizedStyles, this.props.styles);\n\n        // The __cachedInputs__ array is attached to the function and consumed by the\n        // classNamesFunction as a list of keys to include for memoizing classnames.\n\n        // tslint:disable-next-line:no-any\n        (this._styles as any).__cachedInputs__ = [baseStyles, customizedStyles, this.props.styles];\n      }\n    }\n\n    private _onSettingsChanged = (): void => this.forceUpdate();\n  }\n\n  // This preserves backwards compatibility.\n  // tslint:disable-next-line:no-any\n  return Wrapped as any;\n}\n\nfunction _resolve<TStyleProps, TStyleSet extends IStyleSet<TStyleSet>>(\n  styleProps: TStyleProps,\n  ...allStyles: (IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined)[]\n): Partial<TStyleSet> {\n  const result: Partial<TStyleSet>[] = [];\n\n  for (const styles of allStyles) {\n    if (styles) {\n      result.push(typeof styles === 'function' ? styles(styleProps) : styles);\n    }\n  }\n\n  if (result.length === 1) {\n    return result[0] as Partial<TStyleSet>;\n  } else if (result.length) {\n    // cliffkoh: I cannot figure out how to avoid the cast to any here.\n    // It is something to do with the use of Omit in IStyleSet.\n    // It might not be necessary once  Omit becomes part of lib.d.ts (when we remove our own Omit and rely on\n    // the official version).\n    // tslint:disable-next-line:no-any\n    return concatStyleSets(...(result as any)) as any;\n  }\n\n  return {};\n}\n"]}