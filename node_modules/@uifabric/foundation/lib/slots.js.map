{"version":3,"file":"slots.js","sourceRoot":"../src/","sources":["slots.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { IStyle, mergeStyles } from '@uifabric/styling';\nimport { memoizeFunction } from '@uifabric/utilities';\nimport { assign } from './utilities';\nimport { IFactoryOptions } from './IComponent';\nimport {\n  ISlottableReactType,\n  ISlot,\n  ISlots,\n  ISlotDefinition,\n  ISlotFactory,\n  ISlotProp,\n  ISlottableProps,\n  ISlotOptions,\n  IDefaultSlotProps,\n  IProcessedSlotProps,\n  ValidProps,\n  ValidShorthand\n} from './ISlots';\n\n/**\n * This function is required for any module that uses slots.\n *\n * This function is a slot resolver that automatically evaluates slot functions to generate React elements.\n * A byproduct of this resolver is that it removes slots from the React hierarchy by bypassing React.createElement.\n *\n * To use this function on a per-file basis, use the jsx directive targeting withSlots.\n * This directive must be the FIRST LINE in the file to work correctly.\n * Usage of this pragma also requires withSlots import statement.\n *\n * See React.createElement\n */\n// Can't use typeof on React.createElement since it's overloaded. Approximate createElement's signature for now and widen as needed.\nexport function withSlots<P>(\n  type: ISlot<P> | React.FunctionComponent<P> | string,\n  props?: React.Attributes & P | null,\n  // tslint:disable-next-line:missing-optional-annotation\n  ...children: React.ReactNode[]\n): ReturnType<React.FunctionComponent<P>> {\n  const slotType = type as ISlot<P>;\n  if (slotType.isSlot) {\n    // TODO: There is something weird going on here with children embedded in props vs. rest args.\n    // Comment out these lines to see. Make sure this function is doing the right things.\n    const numChildren = React.Children.count(children);\n    if (numChildren === 0) {\n      return slotType(props);\n    }\n\n    // Since we are bypassing createElement, use React.Children.toArray to make sure children are properly assigned keys.\n    // TODO: should this be mutating? does React mutate children subprop with createElement?\n    // TODO: will toArray clobber existing keys?\n    // TODO: React generates warnings because it doesn't detect hidden member _store that is set in createElement.\n    //        Even children passed to createElement without keys don't generate this warning.\n    //        Is there a better way to prevent slots from appearing in hierarchy? toArray doesn't address root issue.\n    children = React.Children.toArray(children);\n\n    return slotType({ ...(props as any), children });\n  } else {\n    // TODO: Are there some cases where children should NOT be spread? Also, spreading reraises perf question.\n    //        Children had to be spread to avoid breaking KeytipData in Toggle.view:\n    //        react-dom.development.js:18931 Uncaught TypeError: children is not a function\n    //        Without spread, function child is a child array of one element\n    // TODO: is there a reason this can't be:\n    // return React.createElement.apply(this, arguments);\n    return React.createElement(type, props, ...children);\n  }\n}\n\n/**\n * This function creates factories that render ouput depending on the user ISlotProp props passed in.\n * @param DefaultComponent - Base component to render when not overridden by user props.\n * @param options - Factory options, including defaultProp value for shorthand prop mapping.\n * @returns ISlotFactory function used for rendering slots.\n */\nexport function createFactory<TProps extends ValidProps, TShorthandProp extends ValidShorthand = never>(\n  DefaultComponent: React.ComponentType<TProps>,\n  options: IFactoryOptions<TProps> = {}\n): ISlotFactory<TProps, TShorthandProp> {\n  const { defaultProp = 'children' } = options;\n\n  const result: ISlotFactory<TProps, TShorthandProp> = (componentProps, userProps, userSlotOptions, defaultStyles) => {\n    // If they passed in raw JSX, just return that.\n    if (React.isValidElement(userProps)) {\n      return userProps;\n    }\n\n    const flattenedUserProps: TProps | undefined = _translateShorthand(defaultProp as string, userProps);\n    const finalProps = _constructFinalProps(defaultStyles, componentProps, flattenedUserProps);\n\n    if (userSlotOptions) {\n      if (userSlotOptions.component) {\n        // TODO: Remove cast if possible. This cast is needed because TS errors on the intrinsic portion of ReactType.\n        // return <userSlotOptions.component {...finalProps} />;\n        const UserComponent = userSlotOptions.component as React.ComponentType<TProps>;\n        return <UserComponent {...finalProps} />;\n      }\n\n      if (userSlotOptions.render) {\n        return userSlotOptions.render(finalProps, DefaultComponent);\n      }\n    }\n\n    return <DefaultComponent {...finalProps} />;\n  };\n\n  return result;\n}\n\n/**\n * Default factory for components without explicit factories.\n */\nconst defaultFactory = memoizeFunction(type => createFactory(type));\n\n/**\n * This function generates slots that can be used in JSX given a definition of slots and their corresponding types.\n * @param userProps - Props as pass to component.\n * @param slots - Slot definition object defining the default slot component for each slot.\n * @returns A set of created slots that components can render in JSX.\n */\nexport function getSlots<TComponentProps extends ISlottableProps<TComponentSlots>, TComponentSlots>(\n  userProps: TComponentProps,\n  slots: ISlotDefinition<Required<TComponentSlots>>\n): ISlots<Required<TComponentSlots>> {\n  const result: ISlots<Required<TComponentSlots>> = {} as ISlots<Required<TComponentSlots>>;\n\n  // userProps already has default props mixed in by createComponent. Recast here to gain typing for this function.\n  const mixedProps = userProps as TComponentProps & IDefaultSlotProps<TComponentSlots>;\n\n  for (const name in slots) {\n    if (slots.hasOwnProperty(name)) {\n      // This closure method requires the use of withSlots to prevent unnecessary rerenders. This is because React detects\n      //  each closure as a different component (since it is a new instance) from the previous one and then forces a rerender of the entire\n      //  slot subtree. For now, the only way to avoid this is to use withSlots, which bypasses the call to React.createElement.\n      const slot: ISlots<Required<TComponentSlots>>[keyof TComponentSlots] = (componentProps, ...args: any[]) => {\n        if (args.length > 0) {\n          // If React.createElement is being incorrectly used with slots, there will be additional arguments.\n          // We can detect these additional arguments and error on their presence.\n          throw new Error('Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.');\n        }\n        // TODO: having TS infer types here seems to cause infinite loop. use explicit types or casting to preserve typing if possible.\n        // TODO: this should be a lookup on TProps property instead of being TProps directly, which is probably causing the infinite loop\n        return _renderSlot<any, any, any>(\n          slots[name],\n          // TODO: this cast to any is hiding a relationship issue between the first two args\n          componentProps as any,\n          mixedProps[name],\n          mixedProps.slots && mixedProps.slots[name],\n          // _defaultStyles should always be present, but a check for existence is added to make view tests easier to use.\n          mixedProps._defaultStyles && mixedProps._defaultStyles[name]\n        );\n      };\n      slot.isSlot = true;\n      result[name] = slot;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Helper function that translates shorthand as needed.\n * @param defaultProp\n * @param slotProps\n */\nfunction _translateShorthand<TProps extends ValidProps, TShorthandProp extends ValidShorthand>(\n  defaultProp: string,\n  slotProps: ISlotProp<TProps, TShorthandProp>\n): TProps | undefined {\n  let transformedProps: TProps | undefined;\n\n  if (typeof slotProps === 'string' || typeof slotProps === 'number' || typeof slotProps === 'boolean') {\n    transformedProps = {\n      [defaultProp]: slotProps as any\n    } as TProps;\n  } else {\n    transformedProps = slotProps as TProps;\n  }\n\n  return transformedProps;\n}\n\n/**\n * Helper function that constructs final styles and props given a series of props ordered by increasing priority.\n */\nfunction _constructFinalProps<TProps extends IProcessedSlotProps>(defaultStyles: IStyle, ...allProps: (TProps | undefined)[]): TProps {\n  const finalProps: TProps = {} as any;\n  const classNames: (string | undefined)[] = [];\n\n  for (const props of allProps) {\n    classNames.push(props && props.className);\n    assign(finalProps, ...(props as any));\n  }\n\n  finalProps.className = mergeStyles(defaultStyles, classNames);\n\n  return finalProps;\n}\n\n/**\n * Render a slot given component and user props. Uses component factory if available, otherwise falls back\n * to default factory.\n * @param ComponentType Factory component type.\n * @param componentProps The properties passed into slot from within the component.\n * @param userProps The user properties passed in from outside of the component.\n */\nfunction _renderSlot<\n  TSlotComponent extends ISlottableReactType<TSlotProps, TSlotShorthand>,\n  TSlotProps extends ValidProps,\n  TSlotShorthand extends ValidShorthand\n>(\n  ComponentType: TSlotComponent,\n  componentProps: TSlotProps,\n  userProps: ISlotProp<TSlotProps, TSlotShorthand>,\n  slotOptions: ISlotOptions<TSlotProps> | undefined,\n  defaultStyles: IStyle\n): ReturnType<React.FunctionComponent> {\n  if (ComponentType.create !== undefined) {\n    return ComponentType.create(componentProps, userProps, slotOptions, defaultStyles);\n  } else {\n    // TODO: need to resolve typing / generic issues passing through memoizeFunction. for now, cast to 'unknown'\n    return ((defaultFactory(ComponentType) as unknown) as ISlotFactory<TSlotProps, TSlotShorthand>)(\n      componentProps,\n      userProps,\n      slotOptions,\n      defaultStyles\n    );\n  }\n}\n"]}