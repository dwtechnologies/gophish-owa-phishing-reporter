// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const childProcess = require("child_process");
const inquirer = require("inquirer");
const office_addin_manifest_1 = require("office-addin-manifest");
const whatwg_url_1 = require("whatwg-url");
exports.EdgeBrowserAppcontainerName = "Microsoft.MicrosoftEdge_8wekyb3d8bbwe";
exports.EdgeWebViewAppcontainerName = "Microsoft.win32webviewhost_cw5n1h2txyewy";
exports.EdgeBrowserName = "Microsoft Edge Web Browser";
exports.EdgeWebViewName = "Microsoft Edge WebView";
/**
 * Adds a loopback exemption for the appcontainer.
 * @param name Appcontainer name
 * @throws Error if platform does not support appcontainers.
 */
function addLoopbackExemptionForAppcontainer(name) {
    if (!isAppcontainerSupported()) {
        throw new Error(`Platform not supported: ${process.platform}.`);
    }
    return new Promise((resolve, reject) => {
        const command = `CheckNetIsolation.exe LoopbackExempt -a -n=${name}`;
        childProcess.exec(command, (error, stdout) => {
            if (error) {
                reject(stdout);
            }
            else {
                resolve();
            }
        });
    });
}
exports.addLoopbackExemptionForAppcontainer = addLoopbackExemptionForAppcontainer;
/**
 * Returns whether appcontainer is supported on the current platform.
 * @returns True if platform supports using appcontainer; false otherwise.
 */
function isAppcontainerSupported() {
    return (process.platform === "win32");
}
exports.isAppcontainerSupported = isAppcontainerSupported;
/**
 * Adds a loopback exemption for the appcontainer.
 * @param name Appcontainer name
 * @throws Error if platform does not support appcontainers.
 */
function isLoopbackExemptionForAppcontainer(name) {
    if (!isAppcontainerSupported()) {
        throw new Error(`Platform not supported: ${process.platform}.`);
    }
    return new Promise((resolve, reject) => {
        const command = `CheckNetIsolation.exe LoopbackExempt -s`;
        childProcess.exec(command, (error, stdout) => {
            if (error) {
                reject(stdout);
            }
            else {
                const expr = new RegExp(`Name: ${name}`, "i");
                const found = expr.test(stdout);
                resolve(found);
            }
        });
    });
}
exports.isLoopbackExemptionForAppcontainer = isLoopbackExemptionForAppcontainer;
/**
 * Returns the name of the appcontainer used to run an Office Add-in.
 * @param sourceLocation Source location of the Office Add-in.
 * @param isFromStore True if installed from the Store; false otherwise.
 */
function getAppcontainerName(sourceLocation, isFromStore = false) {
    const url = new whatwg_url_1.URL(sourceLocation);
    const origin = url.origin;
    const addinType = isFromStore ? 0 : 1; // 0 if from Office Add-in store, 1 otherwise.
    const guid = "04ACA5EC-D79A-43EA-AB47-E50E47DD96FC";
    // Appcontainer name format is "{addinType}_{origin}{guid}".
    // Replace characters ":" and "/" with "_".
    const name = `${addinType}_${origin}${guid}`.replace(/[://]/g, "_");
    return name;
}
exports.getAppcontainerName = getAppcontainerName;
function getUserConfirmation(name) {
    return __awaiter(this, void 0, void 0, function* () {
        const question = {
            message: `Allow localhost loopback for ${name}?`,
            name: "didUserConfirm",
            type: "confirm",
        };
        const answers = yield inquirer.prompt([question]);
        return answers.didUserConfirm;
    });
}
exports.getUserConfirmation = getUserConfirmation;
function getAppcontainerNameFromManifestPath(manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (manifestPath.toLowerCase()) {
            case "edgewebview":
                return exports.EdgeWebViewAppcontainerName;
            case "edgewebbrowser":
            case "edge":
                return exports.EdgeBrowserAppcontainerName;
            default:
                return yield getAppcontainerNameFromManifest(manifestPath);
        }
    });
}
exports.getAppcontainerNameFromManifestPath = getAppcontainerNameFromManifestPath;
function getDisplayNameFromManifestPath(manifestPath) {
    switch (manifestPath.toLowerCase()) {
        case "edgewebview":
            return exports.EdgeWebViewName;
        case "edgewebbrowser":
        case "edge":
            return exports.EdgeBrowserName;
        default:
            return manifestPath;
    }
}
exports.getDisplayNameFromManifestPath = getDisplayNameFromManifestPath;
function ensureLoopbackIsEnabled(manifestPath, askForConfirmation = true) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield getAppcontainerNameFromManifestPath(manifestPath);
        let isEnabled = yield isLoopbackExemptionForAppcontainer(name);
        if (!isEnabled) {
            if (!askForConfirmation || (yield getUserConfirmation(getDisplayNameFromManifestPath(manifestPath)))) {
                yield addLoopbackExemptionForAppcontainer(name);
                isEnabled = true;
            }
        }
        return isEnabled;
    });
}
exports.ensureLoopbackIsEnabled = ensureLoopbackIsEnabled;
/**
 * Returns the name of the appcontainer used to run an Office Add-in.
 * @param manifestPath Path of the manifest file.
 */
function getAppcontainerNameFromManifest(manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const manifest = yield office_addin_manifest_1.readManifestFile(manifestPath);
        const sourceLocation = manifest.defaultSettings ? manifest.defaultSettings.sourceLocation : undefined;
        if (sourceLocation === undefined) {
            throw new Error(`The source location could not be retrieved from the manifest.`);
        }
        return getAppcontainerName(sourceLocation, false);
    });
}
exports.getAppcontainerNameFromManifest = getAppcontainerNameFromManifest;
/**
 * Removes a loopback exemption for the appcontainer.
 * @param name Appcontainer name
 * @throws Error if platform doesn't support appcontainers.
 */
function removeLoopbackExemptionForAppcontainer(name) {
    if (!isAppcontainerSupported()) {
        throw new Error(`Platform not supported: ${process.platform}.`);
    }
    return new Promise((resolve, reject) => {
        const command = `CheckNetIsolation.exe LoopbackExempt -d -n=${name}`;
        childProcess.exec(command, (error, stdout) => {
            if (error) {
                reject(stdout);
            }
            else {
                resolve();
            }
        });
    });
}
exports.removeLoopbackExemptionForAppcontainer = removeLoopbackExemptionForAppcontainer;
//# sourceMappingURL=appcontainer.js.map