// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const util = require("util");
const uuid = require("uuid");
const xml2js = require("xml2js");
const xmlMethods = require("./xml");
const defaults_1 = require("./defaults");
const readFileAsync = util.promisify(fs.readFile);
const writeFileAsync = util.promisify(fs.writeFile);
class DefaultSettings {
}
class ManifestInfo {
}
exports.ManifestInfo = ManifestInfo;
function parseManifest(xml) {
    const manifest = new ManifestInfo();
    const officeApp = xml.OfficeApp;
    if (officeApp) {
        const defaultSettingsXml = xmlMethods.getXmlElement(officeApp, "DefaultSettings");
        manifest.id = xmlMethods.getXmlElementValue(officeApp, "Id");
        manifest.allowSnapshot = xmlMethods.getXmlElementValue(officeApp, "AllowSnapshot");
        manifest.alternateId = xmlMethods.getXmlElementValue(officeApp, "AlternateId");
        manifest.appDomains = xmlMethods.getXmlElementsValue(officeApp, "AppDomains", "AppDomain");
        manifest.defaultLocale = xmlMethods.getXmlElementValue(officeApp, "DefaultLocale");
        manifest.description = xmlMethods.getXmlElementAttributeValue(officeApp, "Description");
        manifest.displayName = xmlMethods.getXmlElementAttributeValue(officeApp, "DisplayName");
        manifest.highResolutionIconUrl = xmlMethods.getXmlElementAttributeValue(officeApp, "HighResolutionIconUrl");
        manifest.hosts = xmlMethods.getXmlElementsAttributeValue(officeApp, "Hosts", "Host", "Name");
        manifest.iconUrl = xmlMethods.getXmlElementAttributeValue(officeApp, "IconUrl");
        manifest.officeAppType = xmlMethods.getXmlAttributeValue(officeApp, "xsi:type");
        manifest.permissions = xmlMethods.getXmlElementValue(officeApp, "Permissions");
        manifest.providerName = xmlMethods.getXmlElementValue(officeApp, "ProviderName");
        manifest.supportUrl = xmlMethods.getXmlElementAttributeValue(officeApp, "SupportUrl");
        manifest.version = xmlMethods.getXmlElementValue(officeApp, "Version");
        if (defaultSettingsXml) {
            const defaultSettings = new DefaultSettings();
            defaultSettings.requestedHeight = xmlMethods.getXmlElementValue(defaultSettingsXml, "RequestedHeight");
            defaultSettings.requestedWidth = xmlMethods.getXmlElementValue(defaultSettingsXml, "RequestedWidth");
            defaultSettings.sourceLocation = xmlMethods.getXmlElementAttributeValue(defaultSettingsXml, "SourceLocation");
            manifest.defaultSettings = defaultSettings;
        }
    }
    return manifest;
}
function modifyManifestFile(manifestPath, guid, displayName) {
    return __awaiter(this, void 0, void 0, function* () {
        let manifestData = {};
        if (manifestPath) {
            if (guid === undefined && displayName === undefined) {
                throw new Error("You need to specify something to change in the manifest.");
            }
            else {
                try {
                    manifestData = yield modifyManifestXml(manifestPath, guid, displayName);
                    yield writeManifestData(manifestPath, manifestData);
                    let output = yield readManifestFile(manifestPath);
                    defaults_1.usageDataObject.sendUsageDataSuccessEvent("modifyManifestFile");
                    return output;
                }
                catch (err) {
                    defaults_1.usageDataObject.sendUsageDataException("modifyManifestFile", err);
                    throw err;
                }
            }
        }
        else {
            throw new Error(`Please provide the path to the manifest file.`);
        }
    });
}
exports.modifyManifestFile = modifyManifestFile;
function modifyManifestXml(manifestPath, guid, displayName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const manifestXml = yield readXmlFromManifestFile(manifestPath);
            setModifiedXmlData(manifestXml.OfficeApp, guid, displayName);
            return manifestXml;
        }
        catch (err) {
            throw new Error(`Unable to modify xml data for manifest file: ${manifestPath}. \n${err}`);
        }
    });
}
function parseXmlAsync(xmlString, manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(function (resolve, reject) {
            return __awaiter(this, void 0, void 0, function* () {
                xml2js.parseString(xmlString, function (parseError, xml) {
                    if (parseError) {
                        reject(new Error(`Unable to parse the manifest file: ${manifestPath}. \n${parseError}`));
                    }
                    else {
                        resolve(xml);
                    }
                });
            });
        });
    });
}
function readManifestFile(manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (manifestPath) {
            const xml = yield readXmlFromManifestFile(manifestPath);
            const manifest = parseManifest(xml);
            return manifest;
        }
        else {
            throw new Error(`Please provide the path to the manifest file.`);
        }
    });
}
exports.readManifestFile = readManifestFile;
function readXmlFromManifestFile(manifestPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileData = yield readFileAsync(manifestPath, { encoding: "utf8" });
        const xml = yield parseXmlAsync(fileData, manifestPath);
        return xml;
    });
}
function setModifiedXmlData(xml, guid, displayName) {
    if (typeof (guid) !== "undefined") {
        if (!guid || guid === "random") {
            guid = uuid();
        }
        xmlMethods.setXmlElementValue(xml, "Id", guid);
    }
    if (typeof (displayName) !== "undefined") {
        xmlMethods.setXmlElementAttributeValue(xml, "DisplayName", displayName);
    }
}
function writeManifestData(manifestPath, manifestData) {
    return __awaiter(this, void 0, void 0, function* () {
        let xml;
        try {
            // Generate xml for the manifest data.
            const builder = new xml2js.Builder();
            xml = builder.buildObject(manifestData);
        }
        catch (err) {
            throw new Error(`Unable to generate xml for the manifest.\n${err}`);
        }
        try {
            // Write the xml back to the manifest file.
            yield writeFileAsync(manifestPath, xml);
        }
        catch (err) {
            throw new Error(`Unable to write to file. ${manifestPath} \n${err}`);
        }
    });
}
//# sourceMappingURL=manifestInfo.js.map